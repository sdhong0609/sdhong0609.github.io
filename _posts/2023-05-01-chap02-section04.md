---
layout: single
title:  "공부 정리: Chapter02 변수와 자료형,연산자 - Section04 코틀린 연산자"
categories: [Kotlin Basic, ]
tag: [kotlin]
---

코틀린에만 있는 연산자와 코틀린에서 사용하지 않는 연산자에 대해 설명한다. 예를 들어 자바의 삼항 연산자는 코틀린에서 사용하지 않는다.

<br>

**수식의 구조**

![chap02-section04-01](/images/2023-05-01-chap02-section04/chap02-section04-01.png)

<br>

**기본 연산자**

산술, 대입, 증가, 감소, 비교, 논리 연산자 등이 있다. 그 중 중요한 것만 여기에 적는다.

* 대입 연산자 (=)
  <br>
  변수에 값을 할당하는 연산자. 이항 연산자 중 우선순위가 가장 낮다. 그래서 다른 연산자의 연산이 모두 끝나면 그때 대입 연산자가 작동한다.
* 증가 연산자와 감소 연산자 (++, --)
  <br>

  ![chap02-section04-02](/images/2023-05-01-chap02-section04/chap02-section04-02.png)

  위의 코드에서 증가 연산자(++)를 앞에 사용하는 경우에는 num1값을 증가한 후 대입하고 증가연산자를 뒤에 사용한 num2의 경우에는 먼저 값을 대입한 후 증가한다.

* 비교 연산자
  <br>
  ===, !== 연산자는 자바에는 없지만 코틀린에는 존재하는 연산자. === 연산자는 2개 항의 참조 주소가 같으면 true, 아니면 false 반환. !== 연산자는 === 연산자와 반대.

* 논리 연산자
  <br>
  논리합 연산자(||) 왼쪽의 항이 true이면 코틀린 컴파일러는 오른쪽 항을 아예 평가(실행)하지 않는다. 논리곱 연산자(&&)도 마찬가지로 왼쪽 항이 false이면 오른쪽 항을 평가하지 않고 바로 false를 반환한다. 이러한 것을 단축 평가(Short Circuit Evaluation)라고 부른다.

<br>
<br>

**비트 연산자**

비트 연산자는 기계가 이해할 수 있는 값인 0과 1을 처리하는 데 사용된다. 프로그래머가 기기를 직접 제어해야 하는 경우 아주 유용. 보통 IoT 기기를 위한 컨트롤러나 프로세서의 레지스터에 접근해야 하는 임베디드 시스템 프로그램 분야에서 많이 사용.

다음은 Int형 값 10을 비트로 표현한 것이다. 10을 비트로 표현하는 방법은 10을 2진수로 바꾸면 된다. 가장 왼쪽에 있는 부호 비트는 양(+), 음(-)을 판단하는 데 사용.

![chap02-section04-03](/images/2023-05-01-chap02-section04/chap02-section04-03.png)

<br>
<br>

**비트 연산을 위한 비트 메서드**

다음은 비트 연산자(메서드)를 정리한 표이다.

![chap02-section04-04](/images/2023-05-01-chap02-section04/chap02-section04-04.png)

메서드처럼 사용해도 되지만 연산자처럼 사용 가능하다. 예를 들어 4.shl(1) 또는 4 shl 1과 같은 방법으로 사용할 수 있다. 4 shl 1과 같이 멤버에 접근하는 점(.) 연산자와 소괄호를 생략하는 표현식을 중위 표현식이라고 부른다.

1. 비트 이동 연산자 shl, shr
   <br>
   shl, shr은 비트를 왼쪽이나 오른쪽으로 밀어낸 다음 사라진 비트의 값은 0으로 채우며 부호 비트는 그대로 둔다. 가장 왼쪽의 부호 비트는 0이 양수, 1이 음수를 의미한다.
   
   비트를 왼쪽으로 1칸 밀어내면 2를 곱하는 것이고 비트를 오른쪽으로 1칸 밀어내면 2를 나누는 것이다.

   비트 이동 연산자는 연산 속도가 아주 빠르다는 장점이 있다. 4에 2를 곱하는 것보다 비트 이동 연산자를 이용하여 비트를 왼쪽으로 1칸 밀어내는 것이 더 빠르다.

   단, 아주 큰 값에 비트 이동 연산자를 사용할 때는 부호 비트에 주의해야 한다. 만약 부호 비트가 바뀌면 예상하지 못한 결과를 얻을 수 있다.

2. 비트 이동 연산자 ushr
   <br>
   ushr을 이용하면 제일 왼쪽 비트에 0을 밀어 넣으면서 오른쪽으로 비트가 이동. 부호 비트까지 포함하여 비트를 밀어낸다. 그래서 음수인 경우 주의해서 사용해야 한다.

3. 논리합 연산자 or
   <br>
   두 수의 비트를 일대일 대응으로 비교하며 비트의 값이 하나라도 1이면 1을 반환.

4. 논리곱 연산자 and
   <br>
   두 비트 값을 비교하여 둘 다 1이면 1을 반환. 그 이외의 경우는 모두 0을 반환.

5. 배타적합 연산자 xor
   <br>
   두 비트 값을 비교하여 같으면 0을, 다르면 1을 반환. xor을 이용하여 2개의 변수 값을 바꿀 수도 있다. 이런 기법을 스왑(Swap)기법이라고 부른다.

6. 반전 연산자 inv
   <br>
   비트를 모두 반대로 뒤집는다. 0을 1로, 1을 0으로 뒤집는다. 단항 연산자이므로 중위 표현법을 사용하지 않고 메서드처럼만 사용가능.


  
<br>
<br>
<br>
<br>
<br>
<br>
[참고 : Do it! 코틀린 프로그래밍](http://www.yes24.com/Product/Goods/74035266)